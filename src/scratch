// src/background.ts

/**
 * @file This is the service worker for the BeachdAI extension.
 * It implements a "Stateful Manager" agent architecture.
 * - A high-level "Manager" (Gemini) maintains a scratchpad and decides on the next thought.
 * - A low-level "Executor" (Ollama) is used as a tool to perform browser actions.
 */

console.log("BeachdAI Service Worker Loaded.");

// --- Types and State Management ---

type TaskStatus = 'PLANNING' | 'THINKING' | 'EXECUTING' | 'COMPLETED' | 'FAILED';

// The internal state of the agent for a given task.
interface AgentState {
  id: string;
  originalGoal: string;
  status: TaskStatus;
  plan: string[]; // The high-level plan generated by the Planner.
  scratchpad: string[]; // The agent's short-term memory and thought process.
  createdAt: number;
  finalAnswer?: string;
  failureReason?: string;
}

// The low-level action performed by the Executor.
interface ExecutorAction {
  action: 'CLICK' | 'TYPE' | 'GOTO' | 'SUBMIT' | 'FINISH';
  selector?: string; // Should target a data-beachdai-id
  text?: string;
  url?: string;
  reasoning?: string;
}

// The high-level thought/action from the Manager.
interface ManagerDecision {
    thought: string;
    action: 'BROWSE' | 'ANSWER' | 'FAIL';
    // For BROWSE actions
    sub_task?: string;
    // For ANSWER actions
    answer?: string;
    // For FAIL actions
    reason?: string;
}

// The output from the new Planner agent.
interface PlannerDecision {
    thought: string;
    plan: string[];
}

let currentTask: AgentState | null = null;
const OLLAMA_API_URL = "http://localhost:11434/api/generate";
const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent";


// --- Extension Lifecycle & Message Handling ---

chrome.runtime.onInstalled.addListener(() => {
  chrome.sidePanel
    .setPanelBehavior({ openPanelOnActionClick: true })
    .catch((error) => console.error(error));
});

chrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {
  if (message.type === 'START_TASK') {
    startManagerLoop(message.task);
    sendResponse({ status: "Task received, starting agent..." });
  } else if (message.type === 'GET_TASK_STATUS') {
      sendResponse({ task: currentTask });
  } else if (message.type === 'STOP_TASK') {
      if (currentTask) {
          updateTaskStatus('FAILED', 'Task stopped by user.');
      }
      sendResponse({ status: "Task stopping..." });
  }
  return true;
});

// --- Core Agent Loop ---

async function startManagerLoop(goal: string) {
  const taskId = `task-${Date.now()}`;
  currentTask = {
    id: taskId,
    originalGoal: goal,
    status: 'PLANNING',
    plan: [],
    scratchpad: [`Goal: ${goal}`],
    createdAt: Date.now()
  };
  updateUI();

  // 1. PLAN
  const planDecision = await getPlannerDecision(goal);
  if (!planDecision || !planDecision.plan || planDecision.plan.length === 0) {
    updateTaskStatus('FAILED', 'Planner (Gemini) failed to create a plan.');
    return;
  }
  currentTask.plan = planDecision.plan;
  addToScratchpad(`Initial Plan: ${planDecision.thought}`);
  updateUI(); // Send the plan to the UI

  const maxTurns = 15; // Safety break
  for (let turn = 0; turn < maxTurns; turn++) {
    if (!currentTask || currentTask.status === 'FAILED' || currentTask.status === 'COMPLETED') {
      console.log("Manager loop halting.");
      break;
    }

    // 2. OBSERVE
    const { tab, pageContent } = await observeCurrentState();
    if (!tab || !pageContent) {
        updateTaskStatus('FAILED', 'Could not observe the current page state.');
        break;
    }

    // 3. THINK
    updateTaskStatus('THINKING');
    const decision = await getManagerDecision(pageContent);
    if (!decision) {
        updateTaskStatus('FAILED', 'Manager (Gemini) failed to make a decision.');
        break;
    }

    addToScratchpad(`Turn ${turn + 1}: ${decision.thought}`);

    // 4. ACT
    updateTaskStatus('EXECUTING');
    if (decision.action === 'BROWSE') {
      if (typeof decision.sub_task === 'string' && decision.sub_task.length > 0) {
        const browseResult = await browseTool(decision.sub_task, tab);
        if (browseResult.success) {
            addToScratchpad(`Observation: Finished browsing. Final page content: ${browseResult.finalContent.substring(0,500)}...`);
        } else {
            // The tool failed, but we don't fail the task. We just log the failure for the Manager to see.
            addToScratchpad(`Observation: The 'BROWSE' tool failed. Reason: ${browseResult.failureReason}. I will re-evaluate my next step.`);
        }
      } else {
        addToScratchpad(`Observation: Manager decided to BROWSE but provided no sub_task. This is likely an error. Moving to next turn.`);
      }
    } else if (decision.action === 'ANSWER' && decision.answer) {
      currentTask.finalAnswer = decision.answer;
      updateTaskStatus('COMPLETED');
    } else if (decision.action === 'FAIL' && decision.reason) {
      updateTaskStatus('FAILED', decision.reason);
    } else {
      updateTaskStatus('FAILED', 'Manager returned an invalid action.');
    }
  }
}

// --- Agent Tools ---

interface BrowseResult {
  success: boolean;
  finalContent: string;
  failureReason?: string;
}

/**
 * The BROWSE tool. Uses the local Ollama agent to perform a series of simple
 * browser interactions to accomplish a sub-task.
 * @param subTask The goal for the browser, e.g., "Find the price of Bitcoin on Google".
 * @param tab The target tab for the actions.
 * @returns A BrowseResult object indicating success or failure.
 */
async function browseTool(subTask: string, tab: chrome.tabs.Tab): Promise<BrowseResult> {
    const maxBrowserTurns = 5;
    let currentPageContent = await getPageContent(tab.id!);
    let stuck = false;

    for (let i = 0; i < maxBrowserTurns; i++) {
        const action = await getExecutionActionFromLLM(subTask, currentPageContent!);
        if (!action || action.action === 'FINISH') {
            addToScratchpad("Executor decided to FINISH the sub-task.");
            break;
        }

        const pageContentBeforeAction = currentPageContent;
        await executeAction(action, tab.id!);
        await new Promise(resolve => setTimeout(resolve, 2000));

        currentPageContent = await getPageContent(tab.id!);

        if (pageContentBeforeAction === currentPageContent) {
            if (action.action === 'CLICK' || action.action === 'SUBMIT' || action.action === 'GOTO') {
                stuck = true;
                break;
            }
             addToScratchpad(`Action ${action.action} did not cause a navigation, which is expected. Continuing sub-task.`);
        }
    }

    if (stuck) {
        return {
            success: false,
            finalContent: currentPageContent!,
            failureReason: "The agent got stuck in a loop, as a navigation action did not change the page content."
        };
    }

    return {
        success: true,
        finalContent: currentPageContent!,
    };
}

// --- LLM Communication ---

async function getPlannerDecision(goal: string): Promise<PlannerDecision | null> {
    const prompt = `
You are a world-class AI, acting as a strategic planner. Your task is to break down a complex user goal into a series of simple, actionable steps.
You have a team of a manager and an executor who will be helping bring your plan to life, using a world-class LLM for reasoning, and a modern web browser as a tool.

**User Goal:** "${goal}"

**Your Task:**
1.  Think step-by-step about how you would accomplish this goal.
2.  Create a concise, high-level, step-by-step plan.
3.  The plan can use web-based actions (e.g., "Search for X," "Extract information from Y," "Compare prices on Z").
4.  The plan can also have steps which recommend thoughts between actions, such as: using the information you got from the prior step, think about [something] and then use the information in the next browsing step.
6.  Your response (the plan) MUST be a JSON object with a "thought" and a "plan" (array of strings).

**Example one - consideration of market trends:**
{
  "thought": "The user wants to know if it's a good time to sell Bitcoin. I need to check the current price, find recent news, and then synthesize an answer.",
  "plan": [
    "Search for the current price of Bitcoin.",
    "Make note of the latest price to use in your later reasoning or searches.",
    "Search for recent news and articles about Bitcoin trends, for example if the price you found is a good price.",
    "Analyze the findings to determine if it's a good time to sell.",
    "Formulate a final answer based on the gathered information."
  ]
}

**Example two - building software:**
{
  "thought": "The user wants to build a snake game. I need to set up a new repo for this, and ask Google Jules to build the game.",
  "plan": [
    "Browse to http://www.Github.com and create a new private repository named 'snake-game'.",
    "Browse to http://jules.google.com and select the new repository from the drop-down.",
    "Create a complete prompt for Jules to create a snake game, and type it in the prompt box",
    "Click the Create Plan button.",
    "Determine if Jules was successful in creating the game, and notify the user."
  ]
}

**Example three - planning a vacation:**
{
  "thought": "The user wants to plan a vacation for under $1000. I need to find a restaurant and a hotel.",
  "plan": [
    "Use a reputable hotel booking site to book a room that leaves some budget for a good meal.",
    "Make note of the remaining budget after the room price.",
    "Use OpenTable to book a restaurant within the remaining budget.",
    "Determine if the bookings were successful, and notify the user."
  ]
}

}

Respond with ONLY the valid JSON object.`;

    try {
        const response = await geminiCall(prompt);
        return response as PlannerDecision;
    } catch (error) {
        console.error("Error in Gemini Planner:", error);
        return null;
    }
}

async function getManagerDecision(pageContent: string): Promise<ManagerDecision | null> {
    const prompt = `
You are a world-class autonomous agent, acting as a manager. Your goal is to solve the user's request by breaking it down into thoughts and actions.

**User Goal:** ${currentTask?.originalGoal}

**Overall Plan:**
${currentTask?.plan.map((step, i) => `${i+1}. ${step}`).join('\n')}

**Your Scratchpad (Memory of previous turns):**
${currentTask?.scratchpad.join('\n')}

**Current Web Page Content (for context):**
\`\`\`html
${pageContent.substring(0, 3000)}
\`\`\`

**Your Task:**
Based on the goal, your scratchpad, and the current page, decide on your next thought and the single action to take.

**Handling Failures:** If your last action resulted in a "tool failed" observation, you MUST analyze the reason and the current page state to decide on a new course of action. You could try the same goal with a different sub-task, or if you are truly stuck, use the 'FAIL' action.

**Available Actions:**
1.  **BROWSE**: Use this when you need to interact with the web to find information. Provide a clear, simple \`sub_task\` for your execution agent.
2.  **ANSWER**: Use this ONLY when you have gathered all necessary information in your scratchpad and are ready to provide the final answer to the user.
3.  **FAIL**: Use this if you are stuck or cannot complete the goal.

**Example 1:**
{
  "thought": "I need to find the current price of Bitcoin. I will use the browser to search for it.",
  "action": "BROWSE",
  "sub_task": "NAVIGATE to google.com and TYPE in the search box, 'current price of Bitcoin'"
}

**Example 2: (handling failures of incomplete execution)**
{
  "thought": "I see the search but I don't see that it has been executed. We need to make sure the search is executed by clicking or pressing enter.",
  "action": "BROWSE",
  "sub_task": "Complete the search by doing a CLICK on the search button, or TYPE enter. You must fully execute the search."
}

**Example 3 (after gathering info):**
{
  "thought": "I have found the price and recent news in my scratchpad. I have enough information to formulate an answer.",
  "action": "ANSWER",
  "answer": "The current price of Bitcoin is $68,000. Given the recent positive news, it may not be the best time to sell, but you should consult a financial advisor."
}

Respond with ONLY a valid JSON object.`;

    try {
        const response = await geminiCall(prompt);
        return response as ManagerDecision;
    } catch (error) {
        console.error("Error in Gemini Manager:", error);
        return null;
    }
}

async function getExecutionActionFromLLM(task: string, pageContent: string): Promise<ExecutorAction | null> {
  // The pageContent is now a JSON string. We'll pass it directly to the LLM.
  const prompt = `
You are an action-oriented execution agent. Your ONLY job is to translate the user's sub-task into a single, concrete action to be performed on the webpage.

**Sub-Task:** "${task}"

**Available Page Elements (in JSON format):**
\`\`\`json
${pageContent.substring(0, 4000)}
\`\`\`

**Your Imperative Task:**
You MUST choose the next logical action to make progress on the sub-task. Analyze the elements and select the best one to interact with. Generate a single JSON object for that action.

**Response Rules:**
1.  **CHOOSE AN ACTION:** Your action MUST be one of: 'CLICK', 'TYPE', 'GOTO', 'SUBMIT'.
2.  **DO NOT FINISH PREMATURELY:** The 'FINISH' action is only allowed if the sub-task has been fully and verifiably completed on the current page. For example, if the task is "Find the price of Bitcoin", you must not FINISH until the price is visible on the page. If the task is "Search for X", you must not FINISH until you have at least submitted the search.
3.  **BE METHODICAL:** For tasks like searching, the sequence is always 'TYPE' first, then 'SUBMIT' in the next turn.
4.  **SELECTOR REQUIRED:** Your selector MUST use the 'beachdai-id' from the element's attributes, formatted as '[data-beachdai-id="..."]'.
5.  **REASONING REQUIRED:** You MUST include a 'reasoning' field to explain why you chose this specific action and element.

**Scenario: The sub-task is "Search for 'latest tech news'"**

*   **Turn 1 (On Google Homepage):** You see an input field. Your job is to TYPE.
    \`\`\`json
    {
      "action": "TYPE",
      "selector": "[data-beachdai-id='some-id-for-search-input']",
      "text": "latest tech news",
      "reasoning": "The sub-task requires a search, so my first step is to type the query into the most likely search input field."
    }
    \`\`\`
*   **Turn 2 (After Typing):** You see the same input field, now filled with text. Your job is to SUBMIT.
    \`\`\`json
    {
      "action": "SUBMIT",
      "selector": "[data-beachdai-id='some-id-for-search-input']",
      "reasoning": "I have already typed the search query. My next and final step for this sub-task is to submit the form to get the results."
    }
    \`\`\`

You must respond with ONLY a valid JSON object. Failure to choose an action will fail the entire task.`;
  try {
    // We can't parse the pageContent here, as it's for the LLM.
    // But we need to parse the LLM's response.
    const response = await ollamaCall(prompt);
    return JSON.parse(response) as ExecutorAction;
  } catch (error) {
    console.error("Error in Ollama Executor:", error);
    // Add the failing response to the scratchpad for debugging
    addToScratchpad(`Ollama Executor failed to return valid JSON. Error: ${error}`);
    return null;
  }
}

// --- Unchanged LLM Call Functions and Helpers ---

async function ollamaCall(prompt: string): Promise<string> {
    const response = await fetch(OLLAMA_API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            model: "llama3:8b",
            prompt: prompt,
            format: "json",
            stream: false
        }),
    });
    if (!response.ok) throw new Error(`Ollama API error: ${response.status}`);
    const result = await response.json();
    return result.response;
}

async function geminiCall(prompt: string): Promise<any> {
    const { geminiApiKey } = await chrome.storage.sync.get('geminiApiKey');
    if (!geminiApiKey) {
        throw new Error("Gemini API key not found. Please set it in the extension options.");
    }
    const response = await fetch(`${GEMINI_API_URL}?key=${geminiApiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: { responseMimeType: "application/json" }
        }),
    });
    if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`Gemini API error: ${response.status} - ${errorBody}`);
    }
    const result = await response.json();
    return JSON.parse(result.candidates[0].content.parts[0].text);
}

function updateTaskStatus(status: TaskStatus, reason?: string) {
    if (currentTask) {
        currentTask.status = status;
        if (reason) currentTask.failureReason = reason;
        updateUI();
    }
}

function addToScratchpad(log: string) {
    if (currentTask) {
        currentTask.scratchpad.push(log);
        updateUI();
    }
}

function updateUI() {
    if (currentTask) {
        chrome.runtime.sendMessage({ type: 'TASK_UPDATE', task: { ...currentTask } });
    }
}

async function observeCurrentState(): Promise<{tab: chrome.tabs.Tab | null, pageContent: string | null}> {
    try {
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (tab && tab.id) {
            const pageContent = await getPageContent(tab.id);
            return { tab, pageContent };
        }
    } catch (error) {
        console.error("Error observing current state:", error);
    }
    return { tab: null, pageContent: null };
}

async function getPageContent(tabId: number): Promise<string | null> {
  try {
    const response = await chrome.tabs.sendMessage(tabId, { action: 'EXTRACT_DOM' });
    return response?.domContent || null;
  } catch (error) {
    console.error(`Error getting page content from tab ${tabId}:`, error);
    return null;
  }
}

async function executeAction(action: ExecutorAction, tabId: number) {
  try {
    await chrome.tabs.sendMessage(tabId, { action: 'EXECUTE_ACTION', payload: action });
  } catch (error) {
    console.error(`Error executing action on tab ${tabId}:`, error);
  }
}
